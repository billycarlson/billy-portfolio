---
interface Section {
  id: string;
  label: string;
  children?: Section[];
}

const { sections = [] } = Astro.props as { sections: Section[] };
---

<nav class="toc" id="toc">
  <a href="#top" class="toc-link toc-back-to-top" data-section="top">
    <span class="toc-icon" aria-hidden="true">â†‘</span>
    Back to Top
  </a>
  {sections.map((section) => (
    <div class="toc-item">
      <a href={`#${section.id}`} data-section={section.id} class="toc-link">
        {section.label}
      </a>
      {section.children && section.children.length > 0 && (
        <div class="toc-children">
          {section.children.map((child) => (
            <div class="toc-item">
              <a href={`#${child.id}`} data-section={child.id} class="toc-link">
                {child.label}
              </a>
            </div>
          ))}
        </div>
      )}
    </div>
  ))}
</nav>

<script>
  // IntersectionObserver to highlight current section in TOC
  document.addEventListener('DOMContentLoaded', () => {
    const toc = document.getElementById('toc');
    if (toc) {
      const links = Array.from(toc.querySelectorAll('a[data-section]'));
      const sectionElements = links
        .filter(link => link.getAttribute('data-section') !== 'top')
        .map(link => {
          const sectionId = link.getAttribute('data-section');
          return {
            link,
            id: sectionId,
            element: sectionId ? document.getElementById(sectionId) : null
          };
        })
        .filter(s => s.element);

      // Back to top handler
      const backToTopLink = links.find(link => link.getAttribute('data-section') === 'top');
      if (backToTopLink) {
        backToTopLink.addEventListener('click', (e) => {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
      }

      if (sectionElements.length > 0) {
        const observerOptions = {
          root: null,
          rootMargin: '-20% 0px -60% 0px',
          threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
          // Find the first intersecting entry (topmost visible section)
          const intersecting = entries
            .filter(e => e.isIntersecting)
            .sort((a, b) => {
              const aRect = a.boundingClientRect;
              const bRect = b.boundingClientRect;
              return aRect.top - bRect.top;
            });

          if (intersecting.length > 0) {
            const activeSection = intersecting[0].target.id;
            
            // Remove active class from all links
            links.forEach(link => link.classList.remove('active'));
            
            // Add active class to current link
            const activeLink = links.find(link => link.getAttribute('data-section') === activeSection);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          } else {
            // If no section is intersecting and we're at the top, highlight back to top
            if (window.scrollY < 100) {
              links.forEach(link => link.classList.remove('active'));
              if (backToTopLink) {
                backToTopLink.classList.add('active');
              }
            }
          }
        }, observerOptions);

        // Observe all sections
        sectionElements.forEach(s => {
          if (s.element) {
            observer.observe(s.element);
          }
        });
      }
    }
  });
</script>

