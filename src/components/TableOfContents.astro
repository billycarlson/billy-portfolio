---
interface Section {
  id: string;
  label: string;
  children?: Section[];
}

const { sections = [] } = Astro.props as { sections: Section[] };
// #region agent log
fetch('http://127.0.0.1:7242/ingest/a78ef623-cca5-4a84-aff8-2f9c4fa8b94d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'TableOfContents.astro:props',message:'sections received',data:{sectionsCount:sections.length,sections:JSON.parse(JSON.stringify(sections)),hasNested:sections.some(s=>s.children&&s.children.length>0)},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'F'})}).catch(()=>{});
// #endregion
---

<nav class="toc" id="toc">
  <a href="#" class="toc-link toc-back-to-top" data-section="top">
    <span class="toc-icon">â†‘</span>
    Back to Top
  </a>
  {sections.map((section) => {
    // #region agent log
    const hasChildren = section.children && section.children.length > 0;
    fetch('http://127.0.0.1:7242/ingest/a78ef623-cca5-4a84-aff8-2f9c4fa8b94d',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'TableOfContents.astro:map',message:'rendering section',data:{sectionId:section.id,sectionLabel:section.label,hasChildren:hasChildren,childrenCount:section.children?.length||0},timestamp:Date.now(),sessionId:'debug-session',runId:'run2',hypothesisId:'F'})}).catch(()=>{});
    // #endregion
    return (
      <div class="toc-item">
        <a href={`#${section.id}`} data-section={section.id} class="toc-link">
          {section.label}
        </a>
        {hasChildren && (
          <div class="toc-children">
            {section.children.map((child) => (
              <div class="toc-item">
                <a href={`#${child.id}`} data-section={child.id} class="toc-link">
                  {child.label}
                </a>
              </div>
            ))}
          </div>
        )}
      </div>
    );
  })}
</nav>

<script>
  // IntersectionObserver to highlight current section in TOC
  document.addEventListener('DOMContentLoaded', () => {
    const toc = document.getElementById('toc');
    if (toc) {
      const links = Array.from(toc.querySelectorAll('a[data-section]'));
      const sectionElements = links
        .filter(link => link.getAttribute('data-section') !== 'top')
        .map(link => {
          const sectionId = link.getAttribute('data-section');
          return {
            link,
            id: sectionId,
            element: sectionId ? document.getElementById(sectionId) : null
          };
        })
        .filter(s => s.element);

      // Back to top handler
      const backToTopLink = links.find(link => link.getAttribute('data-section') === 'top');
      if (backToTopLink) {
        backToTopLink.addEventListener('click', (e) => {
          e.preventDefault();
          window.scrollTo({ top: 0, behavior: 'smooth' });
        });
      }

      if (sectionElements.length > 0) {
        const observerOptions = {
          root: null,
          rootMargin: '-20% 0px -60% 0px',
          threshold: 0
        };

        const observer = new IntersectionObserver((entries) => {
          // Find the first intersecting entry (topmost visible section)
          const intersecting = entries
            .filter(e => e.isIntersecting)
            .sort((a, b) => {
              const aRect = a.boundingClientRect;
              const bRect = b.boundingClientRect;
              return aRect.top - bRect.top;
            });

          if (intersecting.length > 0) {
            const activeSection = intersecting[0].target.id;
            
            // Remove active class from all links
            links.forEach(link => link.classList.remove('active'));
            
            // Add active class to current link
            const activeLink = links.find(link => link.getAttribute('data-section') === activeSection);
            if (activeLink) {
              activeLink.classList.add('active');
            }
          } else {
            // If no section is intersecting and we're at the top, highlight back to top
            if (window.scrollY < 100) {
              links.forEach(link => link.classList.remove('active'));
              if (backToTopLink) {
                backToTopLink.classList.add('active');
              }
            }
          }
        }, observerOptions);

        // Observe all sections
        sectionElements.forEach(s => {
          if (s.element) {
            observer.observe(s.element);
          }
        });
      }
    }
  });
</script>

